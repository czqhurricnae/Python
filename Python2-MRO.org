* C3算法的实现

#+BEGIN_SRC ipython :preamble # -*- coding: utf-8 -*- :results raw drawer output list :exports both :session C3
  import itertools


  def c3(cls, *mro_lists):
      # Make a copy so we don't change existing content
      mro_lists = [list(mro_list[:]) for mro_list in mro_lists]

      # Set up the new MRO with the class itself
      _mro = [cls]

      while True:
          # Reset for the next round of tests
          candidate_found = False

          for mro_list in mro_lists:
              if not len(mro_list):
                  # Any empty lists are of no use to the algorithm
                  continue

              # Get the first item as a potential candidate for the MRO
              candidate = mro_list[0]

              if candidate_found:
                  # Candidate promoted to the MRO are no longer of use
                  if candidate in _mro:
                      mro_list.pop(0)
                      # Don't bother checking any more candidate if one was found
                      # 注意这里continue的对齐是与if condidate_found对齐, 如果是与 if candidate in _mro对齐
                      # 则会导致结果不正确
                      # continue
                  continue

              if candidate in itertools.chain(*(x[1:] for x in mro_lists)):
                  # The candidate was found in an invalid position,
                  # so we move on to the next MRO list to get a new candidate
                  continue
              else:
                  # The candidate is valid and should be promoted to the MRO
                  _mro.append(candidate)
                  mro_list.pop(0)
                  candidate_found = True

          if not sum(len(mro_list) for mro_list in mro_lists):
              # There are no MROs th cycle through, so we're all done
              break
      return _mro


  print c3("C", ["B", "A", "object"], ["A", "object"], ["B", "A"])
#+END_SRC

#+RESULTS:
:RESULTS:
- ['C', 'B', 'A', 'object']
:END:

#+BEGIN_SRC ipython :preamble # -*- coding: utf-8 -*- :results raw drawer output list :exports both :session C3
  print c3("C", ["B", "A", "object"], ["A", "object"])
  print c3("C", ["A", "object"], ["B", "A", "object"])
#+END_SRC

#+RESULTS:
:RESULTS:
- ['C', 'B', 'A', 'object']
- ['C', 'B', 'A', 'object']
:END:
可见当没有`base classes`即`B, A`或者`A, B`参与C3算法时, 结果会都是一样的,
这明显和用户写类继承的寄望值不一致.

#+BEGIN_SRC ipython :preamble # -*- coding: utf-8 -*- :results raw drawer output list :exports both :session
  def c3(*mro_lists):
      mro_lists = [list(mro_list) for mro_list in mro_lists]
      return mro_lists


  print c3("C", ["B", "A", object], ["A", object], ["B", "A"])
#+END_SRC

#+RESULTS:
:RESULTS:
- [['C'], ['B', 'A', <type 'object'>], ['A', <type 'object'>], ['B', 'A']]
:END:

* C3算法与现实的冲突
#+BEGIN_SRC ipython :preamble # -*- coding: utf-8 -*- :results raw drawer output list :exports both :session
  class A(object):
      pass


  class B(A):
      pass


  class C(B, A):
      pass


  # class D(A, B):
  #     pass


  print C.__mro__
  # print D.__mro__
#+END_SRC

#+RESULTS:
:RESULTS:
- (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <type 'object'>)
:END:

#+BEGIN_SRC python
  class A(object):
      pass


  class B(A):
      pass


  class D(A, B):
      pass


  print D.__mro__
#+END_SRC

#+RESULTS:
:RESULTS:
TypeErrorTraceback (most recent call last)
<ipython-input-19-9349c6f8ca52> in <module>()
      7 
      8 
----> 9 class D(A, B):
     10     pass
     11 

TypeError: Error when calling the metaclass bases
    Cannot create a consistent method resolution
order (MRO) for bases B, A
:END:
为什么会出现上述的错误?
因为如果使用C3算法在计算`D.__mro__`时会进入无限循环状态,
即`c3("C", ["A", "object"], ["B", "A", "object"], ["A", "B"])`
所以Python为了让开发者写出有意义的类也是尽了很大的努力.

* C3算法的改进
增加抛出异常功能, 防止进入无线循环.

#+BEGIN_SRC python 
  import itertools


  def c3(cls, *mro_lists):
      # Make a copy so we don't change existing content
      mro_lists = [list(mro_list) for mro_list in mro_lists]

      # Set up the new MRO with the class itself
      _mro = [cls]

      while True:
          # Reset for the next round of tests
          candidate_found = False

          for mro_list in mro_lists:
              if not len(mro_list):
                  # Any empty lists are of no use to the algorithm
                  continue

              # Get the first item as a potential candidate for the MRO
              candidate = mro_list[0]

              if candidate_found:
                  # Candidate promoted to the MRO are no longer of use
                  if candidate in _mro:
                      mro_list.pop(0)
                      # Don't bother checking any more candidate if one was found
                  continue

              if candidate in itertools.chain(*(x[1:] for x in mro_lists)):
                  # The candidate was found in an invalid position,
                  # so we move on to the next MRO list to get a new candidate
                  continue
              else:
                  # The candidate is valid and should be promoted to the MRO
                  _mro.append(candidate)
                  mro_list.pop(0)
                  candidate_found = True

          if not sum(len(mro_list) for mro_list in mro_lists):
              # There are no MROs th cycle through, so we're all done
              break

          if not candidate_found:
              # No valid candidate was available, so we have to bail out
              raise TypeError("Inconsistent MRO")
              break
      return _mro


  print c3("C", ["B", "A", object], ["A", object], ["B", "A"])
  print c3("C", ["A", "object"], ["B", "A", "object"], ["A", "B"])
#+END_SRC

#+RESULTS:
:RESULTS:
- ['C', 'B', 'A', <type 'object'>]
TypeErrorTraceback (most recent call last)
<ipython-input-4-6991f94a6c7f> in <module>()
     50 
     51 print c3("C", ["B", "A", object], ["A", object], ["B", "A"])
---> 52 print c3("C", ["A", "object"], ["B", "A", "object"], ["A", "B"])

<ipython-input-4-6991f94a6c7f> in c3(cls, *mro_lists)
     44         if not candidate_found:
     45             # No valid candidate was available, so we have to bail out
---> 46             raise TypeError("Inconsistent MRO")
     47             break
     48     return _mro

TypeError: Inconsistent MRO
:END:
[TODO:Pro_Python 123]
